groovyLoadLabel = "aws-next-01"
gitUrl = null
gitBranch = null
gitCommit = null
def runWithChecks = null
def dockerBuildMatrix = null
builds = []


def cloneJenkinsfilesRepo() {
    // Clone the remote jenkins file in WORKSPACE_TMP
    dir ("$WORKSPACE_TMP") {
        checkout([  
            $class: 'GitSCM', 
            branches: [[name: 'main']], // TODO RJPP_BRANCH
            doGenerateSubmoduleConfigurations: false, 
            extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: 'jenkinsfiles']], 
            submoduleCfg: [], 
            userRemoteConfigs: [[url: 'https://github.com/mosaicml/testing', credentialsId: "9cf9add1-2cdd-414b-8160-94bd4ac4a13d"]]  // TODO RJPP_SCM_URL
        ])
        env.JENKINSFILES_WORKSPACE = "$WORKSPACE_TMP/jenkinsfiles"
    }
}

def runPytest(pythonVersion, extraDeps, nGpus = 0) {
    runWithChecks(
        name: "pytest/python${pythonVersion}-extraDeps_${extraDeps}-nGpus_${nGpus}",
        title: "Pytest - Python ${pythonVersion}, composer[${extraDeps}], ${nGpus} GPUs",
        summary: "Pytest - Python ${pythonVersion}, composer[${extraDeps}], ${nGpus} GPUs",
    ) {
        builds << build(
            job: 'scratch/pytest',
            parameters: [
                string(name: 'P_CLOUD', value: groovyLoadLabel),
                string(name: 'P_GIT_REPO', value: gitUrl),
                string(name: 'P_GIT_COMMIT', value: gitCommit),
                string(name: 'P_DOCKER_IMAGE', value: "ravimosaicml/pytorch:1.10.0_cpu-python${pythonVersion}-ubuntu20.04"), // TODO: change ravi to mosaicml/pytorch
                string(name: 'P_TIMEOUT', value: '5m'),
                string(name: 'PIP_EXTRA_DEPS', value: extraDeps),
            ]
        )
    }
}



pipeline {
    agent none
    stages {
        stage('Prepare') {
            agent {
                label groovyLoadLabel
            }
            steps {
                script {
                    // In order to print the env and get the commit url and hash, we must be on a real agent
                    sh 'printenv'

                    gitUrl = env.GIT_URL
                    gitBranch = env.GIT_BRANCH
                    gitCommit = env.GIT_COMMIT

                    cloneJenkinsfilesRepo()

                    runWithChecks = load "$JENKINSFILES_WORKSPACE/utils/runWithChecks.groovy"
                    dockerBuildMatrix = load "$JENKINSFILES_WORKSPACE/utils/dockerBuildMatrix.groovy"

                }
            }
        }
        stage('Build Pytorch Docker') {
            // when {
            //     changeset "./docker/pytorch/**"
            // }
            steps {
                script {
                    echo "dockerBuildMatrix $dockerBuildMatrix"
                    echo "gitUrl $gitUrl"
                    echo "gitBranch $gitBranch"
                    echo "runWithChecks $runWithChecks"
                    echo "dockerBuildMatrix $dockerBuildMatrix"
                    dockerBuildMatrix(
                        P_CLOUD: groovyLoadLabel,
                        P_BUILD_MATRIX: './composer/pytorch_build_matrix.sh',
                        P_BUILD_MATRIX_GIT_REPO: 'https://github.com/mosaicml/testing.git',  // TODO RJPP_SCM_URL
                        P_BUILD_MATRIX_GIT_COMMIT: 'main', // TODO RJPP_BRANCH
                        P_DOCKERFILE: 'Dockerfile',
                        P_BUILD_CONTEXT: './docker/pytorch',
                        P_GIT_REPO: gitUrl,
                        P_GIT_COMMIT: gitCommit,
                        P_KANIKO_PUSH_FINAL: gitBranch == "main", // only push if we're on the main branch
                    ) { stagingImage ->
                        if (gitBranch == "main") {
                            // no need to run tests again
                            return
                        }
                        parallel([
                            'dev': { ->
                                build(
                                    job: 'scratch/pytest',
                                    parameters: [
                                        string(name: 'P_CLOUD', value: groovyLoadLabel),
                                        string(name: 'P_GIT_REPO', value: gitUrl),
                                        string(name: 'P_GIT_COMMIT', value: gitCommit),
                                        string(name: 'P_DOCKER_IMAGE', value: dockerImage),
                                        string(name: 'P_TIMEOUT', value: '5m'),
                                        string(name: 'PIP_EXTRA_DEPS', value: 'dev'),
                                    ]
                                )
                            },
                            'all': { ->
                                build(
                                    job: 'scratch/pytest',
                                    parameters: [
                                        string(name: 'P_CLOUD', value: groovyLoadLabel),
                                        string(name: 'P_GIT_REPO', value: gitUrl),
                                        string(name: 'P_GIT_COMMIT', value: gitCommit),
                                        string(name: 'P_DOCKER_IMAGE', value: dockerImage),
                                        string(name: 'P_TIMEOUT', value: '5m'),
                                        string(name: 'PIP_EXTRA_DEPS', value: 'all'),
                                    ]
                                )
                            }
                        ])
                        
                    }
                }
            }
        }
        stage('Build') {
            parallel {
                stage('Lint') {
                    steps {
                        script {
                            runWithChecks(
                                name: 'lint',
                                title: 'Lint',
                                summary: 'Static Analysis Checks',
                            ) {
                                builds << build(
                                    job: 'scratch/lint',
                                    parameters: [
                                        string(name: 'P_CLOUD', value: groovyLoadLabel),
                                        string(name: 'P_GIT_REPO', value: gitUrl),
                                        string(name: 'P_GIT_COMMIT', value: gitCommit),
                                        string(name: 'P_DOCKER_IMAGE', value: "ravimosaicml/pytorch:1.10.0_cpu-python3.9-ubuntu20.04"), // TODO: change ravimosaicml/pytorch to mosaicml/pytorch
                                        string(name: 'P_TIMEOUT', value: '10m'),
                                        string(name: 'PIP_EXTRA_DEPS', value: 'all'),
                                    ]
                                )
                            }
                        }
                    }
                }
                stage('Python 3.7 - All') {
                    steps {
                        script {
                            runPytest("3.7", "all", 0)
                        }
                    }
                }
                stage('Python 3.8 - All') {
                    steps {
                        script {
                            runPytest("3.8", "all", 0)
                        }
                    }
                }
                stage('Python 3.9 - Dev') {
                    steps {
                        script {
                            runPytest("3.9", "dev", 0)
                        }
                    }
                }
                stage('Python 3.9 - All') {
                    steps {
                        script {
                            runPytest("3.9", "all", 0)
                        }
                    }
                }
            }
        }
    }
    post {
        always {
            node("aws-next-01") {
                script {
                    builds.each { item -> 
                        copyArtifacts(
                            projectName: item.projectName,
                            selector: specific("${item.number}"),
                            fingerprintArtifacts: true,
                        )
                    }

                    // sh 'ls -al'

                    // sh 'ls -al build/output/'
                    // archiveArtifacts(artifacts: "build/output/*.xml", fingerprint: true)
                    // junit(allowEmptyResults: true, testResults: "build/output/junit.xml")
                    // publishCoverage(
                    //     adapters: [cobertura(path: "build/output/coverage.xml", mergeToOneReport: true)],
                    //     calculateDiffForChangeRequests: true,
                    //     sourceFileResolver: [level: 'STORE_LAST_BUILD']
                    // )
                }
                
            }
        }
    }
}
